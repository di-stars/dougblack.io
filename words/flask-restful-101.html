<html>
    <head>
        <title>Flask-RESTful 101</title>
        <link rel="stylesheet" href="../assets/stylesheets/global.css">
        <link rel="stylesheet" href="../assets/stylesheets/words.css">
        <link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700' rel='stylesheet' type='text/css'>
    </head>
    <body>
        <div id="header">
            <a href="../index.html"><div id="name">DB</div></a>
        </div>
        <div id="container">
            <div id="title">Flask-RESTful 101</div>
            <div id="date">Posted on September 15th, 2013</div>
            <div id="article">
                <p>There are tons of great frameworks to help you build restful APIs. Today we're going to look at my favorite python framework: <a href="http://flask-restful.readthedocs.org/en/latest/index.html">Flask-RESTful</a>. I'm also completely and totally biased towards it, since it was built by Twilio and I'm currently a maintainer of the <a href="https://github.com/twilio/flask-restful">project</a>. That being said, let's get started.</p>
                <p>Flask-RESTful is an extension of <a href="http://flask.pocoo.org/docs/">Flask</a>, which itself is built on many of the excellent utilities provided by <a href="http://werkzeug.pocoo.org/">Werkzeug</a>. Flask lets you do things like this:</p>

<pre>from flask import Flask
app = Flask(__name__)

@app.route('/&lt;string:path&gt;', methods=['GET'])
def root(path):
    return 'You requested: /' + path

if __name__ == '__main__':
    app.run()
</pre>
                <p>As you might guess, this snippet creates simple Flask server that responds to every request with the path requested. This is cool. Let's see how we might use Flask to build a RESTful API. We need an simple API to build, so let's build an API for managing a set of tasks. A Task API.</p>
                <p>First let's define our endpoints. For this simple example, we'll only have one: <span class="inline-code">/tasks</span>. We need to allow creating a new task, retrieving all tasks, and retrieving a single task. Using what we know about Flask, the code for our Task API might look something like this:</p>
<pre>from flask import Flask, request
import task_db # handles all database interaction

app = Flask(__name__)

@app.route('/tasks', methods=['GET'])
def get_all_tasks():
    return task_db.fetch_all_tasks()

@app.route('/tasks', methods=['POST'])
def create_task():
    task_string = request.form['task']
    task_db.create_task(task_string)
    return task_string

@app.route('/tasks/&lt;int:id&gt;', methods=['GET'])
def get_task(id)
    return task_db.fetch_task(id)
</pre>
                <p>Great! We've got an API for tasks. But, do you see any issues using Flask to build a RESTful API? One of the biggest ideas behind REST is using HTTP to interact with <i>resources</i>. The problem with this code is our resource is split up over multiple methods. There's no encapsulation. While the API itself incorporates basic elements of REST, the code completely fails to capture these ideas. This is bad! There's no reason our internal code shouldn't match the external appearance of our API.</p>
                <p>Enter Flask-RESTful. The same API looks like this in Flask-RESTful.</p>
<pre>from flask import Flask
from flask.ext import restful

app = Flask(__name__)
api = restful.Api(app)

class Users(restful.Resource):
    def get():
        return task_db.fetch_all_tasks()

    def post():
        task_string = request.form['task']
        task_db.create_task(task_string)
        return task_string

class User(restful.Resource)
    def get(id):
        return task_db.fetch_task(id)

api.add_resource(Users, '/users')
api.add_resource(User, '/user/&lt;int:id&gt;')
</pre>
                <p>We have classes now! This is a huge deal. Our routes now map directly to <i>objects</i>. Even better, the methods on a given class are exactly the same as their HTTP counterparts. We no longer have to deal with naming methods on our routes like <span class="inline-code">create_task</span>, since there's a 1 to 1 mapping between HTTP methods and methods on our classes.</p>
                <p>So what's actually happening here? Let's investigate.</p>
                <p>First, we create a Flask-RESTful <span class="inline-code">Api</span> object. The <span class="inline-code">Api</span> object is used to assign our eventual resources to routes. We'll temporarily skip to the end of the script to show what the <span class="inline-code">Api</span> is used for:</p>
<pre>
api.add_resource(Users, '/users')
api.add_resource(User, '/user/&lt;int:id&gt;')
</pre>
                <p>As you might have guessed, these two lines add a given resource to our API at the specified route. We no longer need to enumerate what methods a route supports, since Flask-RESTful resolves this information by inspecting what methods you've defined on your resource object.</p>
                <p>You might be wandering what the <span class="inline-code">&lt;int:id&gt;</span> snippet means. This is called a <i>variable rule</i>. It assigns whatever is in that part of the URI for the incomin request into a variable called "id" which is passed to the get method for User. The "int" part of the rule just makes the type of variable an int instead of a string so we can pass it directly to the <span class="inline-code">fetch_task</span> call.</p>
                <p>Finally, you might be wondering how to get values out of the POST params. Check it out:</p>
<pre>task_string = request.form['task']</pre>
                <p>POST params live on the <span class="inline-code">request</span> object in a <span class="inline-code">form</span> dictionary. It's as simple as that.</p>
                <p>That wraps up this intro. I hope you like what you've seen so far. For more on Flask-RESTful, check out the <a href="http://flask-restful.readthedocs.org/en/latest/quickstart.html">docs</a>.</p>
                <p>If you have an doubts about the viability of Flask-RESTful as framework, I'd like to let you in on a little not-so-secret: the Twilio API is powered by Flask-RESTful (and some other awesome framework magic that I'm saving for another post).</p>
            </div>
            <div id="footer">
                <a href="../words.html"><div id="more-words">MORE WORDS</div></a>
            </div>
        </div>
    </body>
</html>
